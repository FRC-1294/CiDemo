import java.io.*
import groovyx.net.http.HTTPBuilder
import groovyx.net.http.EncoderRegistry
import groovyx.net.http.Method;
import groovyx.net.http.ContentType;
import groovy.json.JsonSlurper
import org.apache.commons.io.FilenameUtils;
import java.nio.file.CopyOption;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;

buildscript {
  repositories {
	mavenCentral()
	maven {
		name = "GradleRIO"
		url = "http://dev.imjac.in/maven"
	}
  }
  dependencies {
    classpath group: 'jaci.openrio.gradle', name: 'GradleRIO', version: '2.0.1'			//Change this line if you wish to Update GradleRIO
    classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.5.2'
    classpath 'commons-io:commons-io:2.4'
  }
}

plugins {
  id "org.10ne.rest" version "0.4.0"
}

apply plugin: 'GradleRIO'                                 //Apply the GradleRIO plugin
apply plugin: 'java'
apply plugin: 'idea'
apply plugin: 'eclipse'

gradlerio.robotClass = "org.usfirst.frc.team1294.robot.Robot"   //The class for the main Robot Class. Used in manifest
gradlerio.team = "1294"                                   //Your FRC team number (e.g. 5333 for team 'Can't C#', or 47 for Chief Delphi)
//gradlerio.rioIP = "10.53.33.20"                         //Uncomment to specify the IP address of the RIO


dependencies {
	compile files(System.properties['user.home'] + '/wpilib/java/extracted/library/lib/NetworkTables.jar')
	compile files(System.properties['user.home'] + '/wpilib/java/extracted/library/lib/WPILib.jar')
}

def robotManifest = {
  attributes 'Main-Class': 'edu.wpi.first.wpilibj.RobotBase'
  attributes 'Robot-Class': gradlerio.robotClass
  attributes 'Class-Path': '.'
  try {
	  def branch = 'git rev-parse --abbrev-ref HEAD'.execute().text.trim()
	  def revision = 'git rev-list --max-count 1 --timestamp HEAD'.execute().text.trim()
	  def commitHash = revision.split(' ').last()
	  def timestamp = revision ? new java.util.Date(java.util.concurrent.TimeUnit.SECONDS.toMillis(revision.split(' ').first() as long)).format("yyyy-MM-dd'T'HH:mm:ssZ") : null
	  def tag = 'git describe'.execute().text.trim()
	  def log = 'git log -1'.execute().text.trim()
	  def author = (log =~ /(?m).*^.*Author: (.*)$/)[0][1]
	  
	  def status = 'git status'.execute().text.trim()
	  def uncommitedCode = !status.contains("nothing to commit, working directory clean")
	  if (uncommitedCode) {
	  	branch = "uncommited code"
	  	commitHash = "uncommited code"
	  	timestamp = "uncommited code"
	  	tag = "uncommited code"
	  	author = "uncommited code"
	  }
	  
	  attributes 'Git-Branch' : branch
	  attributes 'Git-Hash' : commitHash
	  attributes 'Git-Timestamp' : timestamp
	  attributes 'Git-Tag' : tag
	  attributes 'Git-Author' : author  
	  
	  if (project.hasProperty('ciBuild') && ciBuild.toBoolean()) {
	  	attributes 'BuildType' : 'Official Release'
	  } else {
	  	attributes 'BuildType' : 'Dev/Test Build'
	  }
	  
  } catch (Exception ex) {
   
  }
  
}

def downloadReleases() {
	println "Checking github for releases"
	File folder = new File("$buildDir/releases")
	folder.mkdirs()
	def http = new HTTPBuilder("https://api.github.com/repos/FRC-1294/CiDemo/releases")
	http.request(Method.GET, ContentType.TEXT ) { req ->
		headers.'User-Agent' = 'johnrlewis@gmail.com'
		headers.'Accept' = 'application/json'
	    response.success = { resp, reader ->
	        def json = new JsonSlurper().parseText(reader.text)
	        json.each {
	        	if (it.assets[0] != null) {
	        		File output = new File("$buildDir/releases/${it.tag_name}.jar")
	        		if (output.exists()) { 
	        			println "Already have ${it.tag_name}, skipping."
	        		} else {
	        			println "Downloading ${it.tag_name}"
		    			def file = new FileOutputStream(output)
		    			def out = new BufferedOutputStream(file)
		    			out << new URL(it.assets[0].browser_download_url).openStream()
		    			out.close()
	    			}
        		}
	        }
	    }
	}
}

def downloadReleasesTask = project.task('downloadReleases') << {
      downloadReleases()
}

def deployRelease() {
	File releaseFolder = new File("$buildDir/releases")
	def releases = releaseFolder.listFiles().sort(false).reverse()
	
	def console = System.console()
	if (console) {
		console.writer().println("\n\nAvailable Releases:")
		releases.eachWithIndex { it, i ->
			console.writer().println("[$i]: ${FilenameUtils.removeExtension(it.getName())}")
		}
		def releaseIndex = (console.readLine("Which release would you like to deploy? [0]")?:0).toInteger()
		def releasePath = releases[releaseIndex].toPath()
		
		try {
			def host = "roboRIO-${project.gradlerio.team}.local"
			println "Attempting to send new code to RoboRIO..."
	
		    project.ant.scp(file: "${releasePath}",
		    todir:"lvuser@${host}:${project.gradlerio.deployFile}",
		    password:"",
		    port:22,
		    trust:true)
		
		    println "Deploy Successful! Loaded in: ${project.gradlerio.deployFile}"
		    
		    println "Attempting to restart the RoboRIO code..."
		    project.ant.sshexec(host: "${host}",
		    username:"lvuser",
		    port:22,
		    trust:true,
		    password:"",
		    command:"/etc/profile.d/natinst-path.sh; /usr/local/frc/bin/frcKillRobot.sh -t -r"
		    )
		    println "Robot Code is restarting..."
		    
	    } catch (Exception ex) {
	    	println "RoboRIO not available... Falling back to IP..."
	    	String ip = project.gradlerio.rioIP
		    if (ip == "{DEFAULT}") {
		      String team = project.gradlerio.team
		      int length = team.length();
		      if (length < 4)
		      for (int i = 0; i < 4 - length; i++)
		      team = "0" + team;
		
		      ip = "10." + team.substring(0, 2) + "." + team.substring(2, 4) + ".20"
		    }
		    
		    println "Attempting to send new code to RoboRIO..."
	
		    project.ant.scp(file: "${releasePath}",
		    todir:"lvuser@${ip}:${project.gradlerio.deployFile}",
		    password:"",
		    port:22,
		    trust:true)
		
		    println "Deploy Successful! Loaded in: ${project.gradlerio.deployFile}"
		    
		    println "Attempting to restart the RoboRIO code..."
		    project.ant.sshexec(host: "${ip}",
		    username:"lvuser",
		    port:22,
		    trust:true,
		    password:"",
		    command:"/etc/profile.d/natinst-path.sh; /usr/local/frc/bin/frcKillRobot.sh -t -r"
		    )
		    println "Robot Code is restarting..."
		    
	    }
	}
	
}

def deployReleaseTask = project.task('deployRelease') << {
      deployRelease()
}



jar {
  from configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }
  manifest robotManifest
}


task genJavadoc(type: Jar, dependsOn: javadoc) {
  classifier = 'javadoc'
  from javadoc.destinationDir
}

artifacts {
  archives genJavadoc
}

task wrapper(type: Wrapper) {
   gradleVersion = '2.4' //version required
}

